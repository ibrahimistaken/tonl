/**
 * BF001: ReDoS Vulnerability - Exploit Tests
 *
 * These tests MUST FAIL before the fix is applied.
 * After the fix, they should pass (attacks blocked).
 */

import { describe, it } from 'node:test';
import assert from 'node:assert';
import { TONLDocument } from '../../../dist/document.js';

describe('BF001: ReDoS Vulnerability - Exploit Tests', () => {
  describe('Nested Quantifier Attacks', () => {
    it('should block (a+)+ pattern - catastrophic backtracking', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'aaaaaaaaaaaaaaaaaaaaab' }] // 22 'a's + 'b'
      });

      // This pattern causes O(2^n) complexity
      // With 22 chars, this is 4,194,304 operations
      assert.throws(
        () => doc.query('items[?(@.value matches "(a+)+$")]'),
        {
          name: 'SecurityError',
          message: /nested quantifier|unsafe|forbidden/i
        },
        'Should block nested quantifier (a+)+'
      );
    });

    it('should block (a*)* pattern', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      assert.throws(
        () => doc.query('items[?(@.value matches "(a*)*b")]'),
        {
          name: 'SecurityError'
        },
        'Should block (a*)*'
      );
    });

    it('should block (a+)* pattern', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      assert.throws(
        () => doc.query('items[?(@.value matches "(a+)*b")]'),
        {
          name: 'SecurityError'
        },
        'Should block (a+)*'
      );
    });

    it('should block (a|a)* pattern - overlapping alternatives', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      assert.throws(
        () => doc.query('items[?(@.value matches "(a|a)*b")]'),
        {
          name: 'SecurityError'
        },
        'Should block overlapping alternatives'
      );
    });
  });

  describe('Complex Pattern Attacks', () => {
    it('should block complex email-like pattern with catastrophic backtracking', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ email: 'user@example.com' }]
      });

      // This pattern looks legitimate but causes catastrophic backtracking
      assert.throws(
        () => doc.query('items[?(@.email matches "(\\\\w+|\\\\d+)*@")]'),
        {
          name: 'SecurityError'
        },
        'Should block complex alternative repetition'
      );
    });

    it('should block ([a-zA-Z]+)* pattern', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      assert.throws(
        () => doc.query('items[?(@.value matches "([a-zA-Z]+)*$")]'),
        {
          name: 'SecurityError'
        },
        'Should block character class with nested quantifier'
      );
    });

    it('should block (a|ab)* pattern', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      assert.throws(
        () => doc.query('items[?(@.value matches "(a|ab)*c")]'),
        {
          name: 'SecurityError'
        },
        'Should block overlapping alternatives with quantifier'
      );
    });
  });

  describe('Pattern Length Limits', () => {
    it('should reject patterns exceeding 100 character limit', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      // 150 character pattern (exceeds default 100 limit)
      const longPattern = 'a'.repeat(150);

      assert.throws(
        () => doc.query(`items[?(@.value matches "${longPattern}")]`),
        {
          name: 'SecurityError',
          message: /too long|length/i
        },
        'Should reject patterns > 100 chars'
      );
    });

    it('should accept patterns <= 100 characters', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      // 100 character pattern (should be ok)
      const okPattern = 'a'.repeat(100);

      // Should NOT throw for length (might throw for other reasons)
      try {
        doc.query(`items[?(@.value matches "${okPattern}")]`);
      } catch (error: any) {
        assert.ok(!error.message.includes('too long'));
      }
    });
  });

  describe('Timeout Protection', () => {
    it('should execute safe patterns quickly', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'a'.repeat(30) }] // 30 'a's
      });

      // Single quantifier 'a+' is actually safe (no nesting)
      // This test verifies safe patterns execute quickly
      const start = Date.now();

      const result = doc.query('items[?(@.value matches "a+")]');
      const duration = Date.now() - start;

      // Should execute quickly (< 200ms)
      assert.ok(
        duration < 200,
        `Query took ${duration}ms, expected <200ms`
      );

      // Should match the value
      assert.strictEqual(result.length, 1);
    });
  });

  describe('Safe Pattern Allowlist', () => {
    it('should allow simple wildcard patterns', () => {
      const doc = TONLDocument.fromJSON({
        items: [
          { email: 'alice@example.com' },
          { email: 'bob@test.org' },
          { email: 'invalid' }
        ]
      });

      // Simple safe pattern - should work
      const result = doc.query('items[?(@.email matches ".*@.*")]');

      assert.strictEqual(result.length, 2, 'Should match 2 emails');
    });

    it('should allow character class patterns', () => {
      const doc = TONLDocument.fromJSON({
        items: [
          { name: 'alice' },
          { name: 'bob123' }
        ]
      });

      // Safe character class - should work
      const result = doc.query('items[?(@.name matches "^[a-z]+$")]');

      assert.strictEqual(result.length, 1, 'Should match only "alice"');
    });

    it('should allow single quantifiers (non-nested)', () => {
      const doc = TONLDocument.fromJSON({
        items: [
          { url: 'http://example.com' },
          { url: 'https://test.org' }
        ]
      });

      // Safe pattern with single quantifiers
      const result = doc.query('items[?(@.url matches "^https?://")]');

      assert.strictEqual(result.length, 2, 'Should match both URLs');
    });
  });

  describe('matches operator - Both code paths protected', () => {
    it('should block ReDoS in matches operator (covers both vulnerable lines)', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'aaaaaaaaaaaaaaaaaaaaab' }]
      });

      // This tests the operator syntax which uses the secure regex executor
      // Both lines 92-97 and the function expression evaluator are protected
      assert.throws(
        () => doc.query('items[?(@.value matches "(a+)+$")]'),
        {
          name: 'SecurityError'
        },
        'Should block ReDoS in matches operator'
      );
    });
  });

  describe('Regression Tests - Legitimate Use Cases', () => {
    it('should still match email patterns correctly', () => {
      const doc = TONLDocument.fromJSON({
        users: [
          { email: 'alice@example.com' },
          { email: 'bob@test.org' },
          { email: 'invalid-email' }
        ]
      });

      // Safe email pattern
      const result = doc.query('users[?(@.email matches "^[^@]+@[^@]+\\\\.[^@]+$")]');

      assert.strictEqual(result.length, 2, 'Should match valid emails');
      assert.strictEqual(result[0].email, 'alice@example.com');
      assert.strictEqual(result[1].email, 'bob@test.org');
    });

    it('should still support case patterns', () => {
      const doc = TONLDocument.fromJSON({
        items: [
          { name: 'Apple' },
          { name: 'banana' },
          { name: 'Cherry' }
        ]
      });

      // Safe pattern matching
      const result = doc.query('items[?(@.name matches "^[A-Z]")]');

      assert.strictEqual(result.length, 2, 'Should match capitalized names');
    });

    it('should reject invalid regex syntax gracefully', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      // Invalid regex: unclosed bracket
      assert.throws(
        () => doc.query('items[?(@.value matches "[")]'),
        Error,
        'Should throw on invalid regex'
      );
    });

    it('should handle empty patterns', () => {
      const doc = TONLDocument.fromJSON({
        items: [{ value: 'test' }]
      });

      // Empty pattern
      const result = doc.query('items[?(@.value matches "")]');

      // Empty pattern matches everything
      assert.strictEqual(result.length, 1);
    });
  });
});
